/*
 * ConviSize - Smart Image Converter
 * Optimized and minified version
 */

document.addEventListener('DOMContentLoaded', () => {
    // Main application object
    const ConviSize = {
        // DOM elements
        elements: {
            dropArea: document.getElementById('dropArea'),
            fileInput: document.getElementById('fileInput'),
            chooseFileBtn: document.getElementById('chooseFileBtn'),
            formatSelect: document.getElementById('formatSelect'),
            qualitySlider: document.getElementById('qualitySlider'),
            widthInput: document.getElementById('widthInput'),
            heightInput: document.getElementById('heightInput'),
            aspectRatio: document.getElementById('aspectRatio'),
            filterOptions: document.querySelectorAll('input[name="filter"]'),
            convertBtn: document.getElementById('convertBtn'),
            outputPreview: document.getElementById('outputPreview'),
            downloadBtn: document.getElementById('downloadBtn')
        },
        
        // Application state
        state: {
            selectedImages: [],
            currentImageIndex: 0,
            originalImage: null,
        },
        
        // Initialize the application
        init() {
            this.setupEventListeners();
            this.populateFormatOptions();
        },
        
        // Set up event listeners
        setupEventListeners() {
            const { elements } = this;
            
            // File input events
            elements.fileInput.addEventListener('change', this.handleFileSelect.bind(this));
            
            // Choose file button
            elements.chooseFileBtn.addEventListener('click', () => elements.fileInput.click());
            
            // Drag and drop events
            elements.dropArea.addEventListener('dragover', this.handleDragOver.bind(this));
            elements.dropArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
            elements.dropArea.addEventListener('drop', this.handleDrop.bind(this));
            
            // Dimension input events
            elements.widthInput.addEventListener('input', this.handleWidthChange.bind(this));
            elements.heightInput.addEventListener('input', this.handleHeightChange.bind(this));
            
            // Convert button
            elements.convertBtn.addEventListener('click', this.convertImage.bind(this));
        },
        
        // Populate format options with popularity sorting
        populateFormatOptions() {
            const formats = [
                { value: 'jpeg', label: 'JPEG', popular: true },
                { value: 'png', label: 'PNG', popular: true },
                { value: 'webp', label: 'WebP', popular: true },
                { value: 'pdf', label: 'PDF', popular: false },
                { value: 'gif', label: 'GIF', popular: false },
                { value: 'bmp', label: 'BMP', popular: false }
            ];
            
            const sortedFormats = this.sortFormatsByPopularity(formats);
            const formatSelect = this.elements.formatSelect;
            
            formatSelect.innerHTML = '';
            sortedFormats.forEach(format => {
                const option = document.createElement('option');
                option.value = format.value;
                option.textContent = format.label;
                formatSelect.appendChild(option);
            });
        },
        
        // Sort formats by popularity
        sortFormatsByPopularity(formats) {
            return formats.sort((a, b) => {
                if (a.popular && !b.popular) return -1;
                if (!a.popular && b.popular) return 1;
                return 0;
            });
        },
        
        // Handle drag over
        handleDragOver(e) {
            e.preventDefault();
            this.elements.dropArea.classList.add('drag-over');
        },
        
        // Handle drag leave
        handleDragLeave(e) {
            e.preventDefault();
            this.elements.dropArea.classList.remove('drag-over');
        },
        
        // Handle drop
        handleDrop(e) {
            e.preventDefault();
            this.elements.dropArea.classList.remove('drag-over');
            
            if (e.dataTransfer.files.length) {
                this.handleFiles(e.dataTransfer.files);
            }
        },
        
        // Handle file selection
        handleFileSelect(e) {
            this.handleFiles(e.target.files);
        },
        
        // Handle multiple files
        handleFiles(files) {
            if (files.length === 0) return;
            
            // Clear previous selections
            this.state.selectedImages = [];
            const dropArea = this.elements.dropArea;
            dropArea.innerHTML = '';
            
            // Create image container
            const imageContainer = document.createElement('div');
            imageContainer.className = 'multi-image-selection';
            
            // Add counter
            const counterText = document.createElement('div');
            counterText.className = 'image-counter';
            counterText.textContent = `Selected ${files.length} image${files.length > 1 ? 's' : ''}`;
            
            // Process each file with lazy loading
            Array.from(files).forEach((file, index) => {
                if (file.type.match('image.*')) {
                    this.processImageFile(file, imageContainer, index);
                }
            });
        },
        
        // Process image file with performance optimizations
        processImageFile(file, container, index) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                // Use createImageBitmap for better performance when available
                if ('createImageBitmap' in window) {
                    // Create a blob from the file
                    const blob = new Blob([new Uint8Array(e.target.result)], {type: file.type});
                    
                    createImageBitmap(blob).then(bitmap => {
                        this.addImageToSelection(bitmap, file, container, index, e.target.result);
                    }).catch(() => {
                        // Fallback to Image if createImageBitmap fails
                        this.createImageFallback(e.target.result, file, container, index);
                    });
                } else {
                    // Fallback for browsers without createImageBitmap
                    this.createImageFallback(e.target.result, file, container, index);
                }
            };
            
            // Read as array buffer for better performance with large images
            reader.readAsArrayBuffer(file);
        },
        
        // Fallback to traditional Image object
        createImageFallback(src, file, container, index) {
            const img = new Image();
            
            img.onload = () => {
                this.addImageToSelection(img, file, container, index, src);
            };
            
            img.src = URL.createObjectURL(file);
        },
        
        // Add image to selection
        addImageToSelection(img, file, container, index, src) {
            // Store image data
            this.state.selectedImages.push({
                img: img,
                width: img.width || img.naturalWidth,
                height: img.height || img.naturalHeight,
                aspectRatio: (img.width || img.naturalWidth) / (img.height || img.naturalHeight),
                file: file,
                src: src
            });
            
            // Create thumbnail with lazy loading
            const thumbnail = document.createElement('div');
            thumbnail.className = 'image-thumbnail';
            thumbnail.dataset.index = this.state.selectedImages.length - 1;
            thumbnail.onclick = () => {
                this.selectImage(parseInt(thumbnail.dataset.index));
            };
            
            const thumbImg = document.createElement('img');
            thumbImg.loading = 'lazy'; // Use native lazy loading
            const objectURL = URL.createObjectURL(file);
            thumbImg.src = objectURL;
            thumbImg.alt = `Image ${this.state.selectedImages.length}`;
            
            // Clean up object URL when image loads
            thumbImg.onload = () => {
                URL.revokeObjectURL(objectURL);
            };
            
            thumbnail.appendChild(thumbImg);
            container.appendChild(thumbnail);
            
            // If this is the first image, select it
            if (this.state.selectedImages.length === 1) {
                this.selectImage(0);
            }
            
            // Enable convert button
            this.elements.convertBtn.disabled = false;
            
            // Add batch conversion options if multiple images
            if (this.state.selectedImages.length > 1 && !document.getElementById('batchOptions')) {
                this.addBatchConversionOptions();
            }
        },
        
        // Add batch conversion options
        addBatchConversionOptions() {
            const dropArea = this.elements.dropArea;
            
            // Create batch options container
            const batchOptions = document.createElement('div');
            batchOptions.className = 'batch-options';
            batchOptions.id = 'batchOptions';
            
            // Convert all button
            const convertAllBtn = document.createElement('button');
            convertAllBtn.className = 'btn primary-btn';
            convertAllBtn.id = 'convertAllBtn';
            convertAllBtn.textContent = 'Convert & Download All';
            convertAllBtn.onclick = () => this.convertAllImages();
            
            // Consolidated PDF button
            const consolidatedPdfBtn = document.createElement('button');
            consolidatedPdfBtn.className = 'btn secondary-btn';
            consolidatedPdfBtn.id = 'consolidatedPdfBtn';
            consolidatedPdfBtn.textContent = 'Create Single PDF';
            consolidatedPdfBtn.onclick = () => this.createConsolidatedPdf();
            
            batchOptions.appendChild(convertAllBtn);
            batchOptions.appendChild(consolidatedPdfBtn);
            dropArea.appendChild(batchOptions);
        },
        
        // Select image for editing
        selectImage(index) {
            if (index < 0 || index >= this.state.selectedImages.length) return;
            
            this.state.currentImageIndex = index;
            const imageData = this.state.selectedImages[index];
            
            // Update thumbnails selection
            const thumbnails = document.querySelectorAll('.image-thumbnail');
            thumbnails.forEach((thumb, i) => {
                thumb.classList.toggle('selected', i === index);
            });
            
            // Update dimension inputs
            this.elements.widthInput.value = imageData.width;
            this.elements.heightInput.value = imageData.height;
            
            // Store original image for aspect ratio calculations
            this.state.originalImage = imageData;
        },
        
        // Handle width change
        handleWidthChange() {
            const { elements, state } = this;
            const newWidth = parseInt(elements.widthInput.value);
            
            if (isNaN(newWidth) || newWidth <= 0) return;
            
            if (elements.aspectRatio.checked && state.originalImage) {
                const newHeight = Math.round(newWidth / state.originalImage.aspectRatio);
                elements.heightInput.value = newHeight;
            }
        },
        
        // Handle height change
        handleHeightChange() {
            const { elements, state } = this;
            const newHeight = parseInt(elements.heightInput.value);
            
            if (isNaN(newHeight) || newHeight <= 0) return;
            
            if (elements.aspectRatio.checked && state.originalImage) {
                const newWidth = Math.round(newHeight * state.originalImage.aspectRatio);
                elements.widthInput.value = newWidth;
            }
        },
        
        // Convert current image
        convertImage() {
            const { elements, state } = this;
            
            if (state.selectedImages.length === 0) return;
            
            // Show loading indicator
            this.showLoading();
            
            // Get selected image
            const imageData = state.selectedImages[state.currentImageIndex];
            
            // Get conversion settings
            const format = elements.formatSelect.value;
            const quality = parseInt(elements.qualitySlider.value) / 100;
            const width = parseInt(elements.widthInput.value) || imageData.width;
            const height = parseInt(elements.heightInput.value) || imageData.height;
            
            // Get selected filter
            let filter = 'none';
            elements.filterOptions.forEach(option => {
                if (option.checked) filter = option.value;
            });
            
            try {
                // Process the image
                this.processImage(imageData.img, format, quality, width, height, filter);
            } catch (error) {
                console.error('Error converting image:', error);
                this.hideLoading();
                alert('An error occurred while converting the image. Please try again.');
            }
        },
        
        // Process image with canvas
        processImage(image, format, quality, width, height, filter) {
            // Create canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = width;
            canvas.height = height;
            
            // Apply filter
            ctx.filter = this.getFilterString(filter);
            
            // Draw image
            ctx.drawImage(image, 0, 0, width, height);
            
            // Convert to desired format
            let dataURL;
            let mimeType;
            
            if (format === 'pdf') {
                // Handle PDF creation
                try {
                    mimeType = 'application/pdf';
                    this.createPDF(canvas, width, height);
                    return;
                } catch (error) {
                    console.error('Error creating PDF in processImage:', error);
                    throw new Error('Failed to create PDF: ' + error.message);
                }
            } else {
                // Handle image formats
                switch (format) {
                    case 'jpeg':
                        mimeType = 'image/jpeg';
                        break;
                    case 'png':
                        mimeType = 'image/png';
                        break;
                    case 'webp':
                        mimeType = 'image/webp';
                        break;
                    case 'gif':
                        mimeType = 'image/gif';
                        break;
                    case 'bmp':
                        mimeType = 'image/bmp';
                        break;
                    default:
                        mimeType = 'image/jpeg';
                }
                
                if (format === 'jpeg' || format === 'webp') {
                    dataURL = canvas.toDataURL(mimeType, quality);
                } else {
                    dataURL = canvas.toDataURL(mimeType);
                }
                
                // Update preview and enable download
                this.updatePreview(dataURL, format);
                this.hideLoading();
            }
        },
        
        // Create PDF from canvas
        createPDF(canvas, width, height) {
            const { jsPDF } = window;
            
            if (!jsPDF) {
                throw new Error('jsPDF library not loaded');
            }
            
            // Calculate PDF dimensions (A4 size in mm)
            const pdfWidth = 210;
            const pdfHeight = 297;
            const aspectRatio = width / height;
            
            let imgWidth, imgHeight;
            if (aspectRatio > pdfWidth / pdfHeight) {
                imgWidth = pdfWidth;
                imgHeight = pdfWidth / aspectRatio;
            } else {
                imgHeight = pdfHeight;
                imgWidth = pdfHeight * aspectRatio;
            }
            
            // Create PDF
            const pdf = new jsPDF();
            const imgData = canvas.toDataURL('image/jpeg', 0.95);
            
            pdf.addImage(imgData, 'JPEG', 0, 0, imgWidth, imgHeight);
            
            // Create blob and update preview
            const pdfBlob = pdf.output('blob');
            const pdfURL = URL.createObjectURL(pdfBlob);
            
            this.updatePreview(pdfURL, 'pdf');
            this.hideLoading();
        },
        
        // Get filter string for canvas
        getFilterString(filter) {
            switch (filter) {
                case 'grayscale': return 'grayscale(100%)';
                case 'sepia': return 'sepia(100%)';
                case 'invert': return 'invert(100%)';
                default: return 'none';
            }
        },
        
        // Update preview
        updatePreview(dataURL, format) {
            const outputPreview = this.elements.outputPreview;
            const downloadBtn = this.elements.downloadBtn;
            
            // Clear previous content
            outputPreview.innerHTML = '';
            
            if (format === 'pdf') {
                // Create PDF preview
                const pdfPreview = document.createElement('div');
                pdfPreview.className = 'pdf-preview';
                
                // Add PDF icon
                const pdfIcon = document.createElement('div');
                pdfIcon.className = 'pdf-icon';
                pdfIcon.innerHTML = '<svg width="50" height="50" viewBox="0 0 24 24"><path fill="#e74c3c" d="M12 16.5l4-4h-3v-9h-2v9H8l4 4zm9-13h-6v1.5h6v15H3v-15h6V3.5H3c-.83 0-1.5.67-1.5 1.5v15c0 .83.67 1.5 1.5 1.5h18c.83 0 1.5-.67 1.5-1.5V5c0-.83-.67-1.5-1.5-1.5z"/></svg>';
                
                // Add message
                const pdfMessage = document.createElement('p');
                pdfMessage.textContent = 'PDF created successfully. Click the download button to save.';
                
                pdfPreview.appendChild(pdfIcon);
                pdfPreview.appendChild(pdfMessage);
                outputPreview.appendChild(pdfPreview);
            } else {
                // Create image element for image formats
                const img = document.createElement('img');
                img.src = dataURL;
                img.alt = 'Converted Image';
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                outputPreview.appendChild(img);
            }
            
            // Set up download
            downloadBtn.href = dataURL;
            downloadBtn.download = `converted-image.${format}`;
            downloadBtn.style.display = 'inline-block';
        },
        
        // Convert all images
        convertAllImages() {
            const { elements, state } = this;
            
            if (state.selectedImages.length <= 1) return;
            
            // Show loading indicator
            this.showLoading('Converting images...');
            
            // Get conversion settings
            const format = elements.formatSelect.value;
            const quality = parseInt(elements.qualitySlider.value) / 100;
            
            // Get selected filter
            let filter = 'none';
            elements.filterOptions.forEach(option => {
                if (option.checked) filter = option.value;
            });
            
            try {
                // Process all images
                this.processBatchImages(0, format, quality, filter);
            } catch (error) {
                console.error('Error in batch conversion:', error);
                this.hideLoading();
                alert('An error occurred during batch conversion. Please try again.');
            }
        },
        
        // Process batch images recursively
        processBatchImages(index, format, quality, filter) {
            const { state } = this;
            
            if (index >= state.selectedImages.length) {
                this.hideLoading();
                alert('All images converted successfully!');
                return;
            }
            
            const imageData = state.selectedImages[index];
            const width = parseInt(this.elements.widthInput.value) || imageData.width;
            const height = parseInt(this.elements.heightInput.value) || imageData.height;
            
            try {
                // Create canvas
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = width;
                canvas.height = height;
                
                // Apply filter
                ctx.filter = this.getFilterString(filter);
                
                // Draw image
                ctx.drawImage(imageData.img, 0, 0, width, height);
                
                // Convert to desired format
                let dataURL;
                let mimeType;
                
                switch (format) {
                    case 'jpeg':
                        mimeType = 'image/jpeg';
                        break;
                    case 'png':
                        mimeType = 'image/png';
                        break;
                    case 'webp':
                        mimeType = 'image/webp';
                        break;
                    case 'gif':
                        mimeType = 'image/gif';
                        break;
                    case 'bmp':
                        mimeType = 'image/bmp';
                        break;
                    default:
                        mimeType = 'image/jpeg';
                }
                
                if (format === 'jpeg' || format === 'webp') {
                    const dataURL = canvas.toDataURL(mimeType, quality);
                } else {
                    const dataURL = canvas.toDataURL(mimeType);
                }
                
                // Create download link
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = `converted-image-${index + 1}.${format}`;
                link.click();
                
                // Process next image
                setTimeout(() => {
                    this.processBatchImages(index + 1, format, quality, filter);
                }, 100);
                
            } catch (error) {
                console.error(`Error processing image ${index}:`, error);
                this.hideLoading();
                alert(`An error occurred while processing image ${index + 1}. Please try again.`);
            }
        },
        
        // Show loading indicator
        showLoading(message = 'Processing...') {
            const loadingEl = document.createElement('div');
            loadingEl.className = 'loading-message';
            loadingEl.id = 'loadingMessage';
            loadingEl.textContent = message;
            document.body.appendChild(loadingEl);
        },
        
        // Create consolidated PDF from all images
        createConsolidatedPdf() {
            const { elements, state } = this;
            
            if (state.selectedImages.length <= 1) {
                alert('Please select multiple images to create a consolidated PDF');
                return;
            }
            
            // Show loading indicator
            this.showLoading('Creating consolidated PDF...');
            
            // Get conversion settings
            const width = parseInt(elements.widthInput.value) || state.selectedImages[0].width;
            const height = parseInt(elements.heightInput.value) || state.selectedImages[0].height;
            
            // Get selected filter
            let filter = 'none';
            elements.filterOptions.forEach(option => {
                if (option.checked) filter = option.value;
            });
            
            try {
                const { jsPDF } = window;
                
                if (!jsPDF) {
                    throw new Error('jsPDF library not loaded');
                }
                
                const pdf = new jsPDF();
                this.addImagesToPdf(pdf, 0, width, height, filter);
            } catch (error) {
                console.error('Error creating PDF:', error);
                this.hideLoading();
                alert('An error occurred while creating the PDF. Please try again.');
            }
        },
        
        // Add images to PDF recursively
        addImagesToPdf(pdf, index, width, height, filter) {
            const { state } = this;
            
            if (index >= state.selectedImages.length) {
                // Save and download PDF
                const pdfBlob = pdf.output('blob');
                const pdfURL = URL.createObjectURL(pdfBlob);
                
                // Update preview
                this.updatePreview(pdfURL, 'pdf');
                
                // Create download link
                const link = document.createElement('a');
                link.href = pdfURL;
                link.download = 'consolidated-images.pdf';
                link.click();
                
                this.hideLoading();
                return;
            }
            
            try {
                const imageData = state.selectedImages[index];
                
                // Create canvas for this image
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = width;
                canvas.height = height;
                
                // Apply filter
                ctx.filter = this.getFilterString(filter);
                
                // Draw image
                ctx.drawImage(imageData.img, 0, 0, width, height);
                
                // Convert to data URL
                const imgData = canvas.toDataURL('image/jpeg', 0.95);
                
                // Add new page if not the first image
                if (index > 0) {
                    pdf.addPage();
                }
                
                // Calculate image dimensions for PDF
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const aspectRatio = width / height;
                
                let imgWidth, imgHeight;
                if (aspectRatio > pageWidth / pageHeight) {
                    imgWidth = pageWidth;
                    imgHeight = pageWidth / aspectRatio;
                } else {
                    imgHeight = pageHeight;
                    imgWidth = pageHeight * aspectRatio;
                }
                
                // Add image to PDF
                pdf.addImage(imgData, 'JPEG', 0, 0, imgWidth, imgHeight);
                
                // Process next image
                setTimeout(() => {
                    this.addImagesToPdf(pdf, index + 1, width, height, filter);
                }, 50);
                
            } catch (error) {
                console.error('Error adding image to PDF:', error);
                this.hideLoading();
                alert('An error occurred while creating the PDF. Please try again.');
            }
        },
        
        // Hide loading indicator
        hideLoading() {
            const loadingEl = document.getElementById('loadingMessage');
            if (loadingEl) loadingEl.remove();
        }
    };
    
    // Initialize the application
    ConviSize.init();
});